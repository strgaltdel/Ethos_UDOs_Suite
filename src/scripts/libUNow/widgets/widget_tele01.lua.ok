-- future enhancements:
-- dynamic calculation of num pages & rows per page 

-- **************************************************************************************
-- *************************    unspecific Tele draw functions **************************
-- **************************************************************************************

local sensors 		= {}	

local layout_T01 	= {}
local pageLayout	= {}
local dspType 
	
	
---------------
-- Define config string
---------------

function conf_teleEl()
	widgetconfLine["teleEl"]="!tele,void"		-- no special configuration
end


function displayTele(label,sensor,x,y,iconsize,frameX,theme,dy,layout,layout_T01,demoMode)					-- display telemetry values; sizing in standard 2x4 arrangement (2 cols / 4 rows)

	local col_Value 	= theme.c_textStd
	local col_Value2 	= theme.c_textgrey1
	lcd.color(col_Value)

	lcd.color(theme.c_textStd)
	lcd.font(txtSize.std)
	--lcd.font(FONT_XL_BOLD)	-- test
	local value, valueStrg
	local bmpY=0
	
	if iconsize.height < 14 then
		bmpY =12-iconsize.height
	end
	
	--  *************   Tab calculation    ***********
	local tmpOffset
	if x < 20 then					-- left column
		tmpOffset = layout_T01.TabL1	
	else
		tmpOffset = layout_T01.TabR1
	end
	
	local xB_offset = tmpOffset+sensor.alignB*frameX.w/1000
	local xV_offset = layout_T01.offTele1+tmpOffset+sensor.alignV*frameX.w/1000
-- ***************************   exception handling **********************************************
--	print("Tabs: x",x)
	if sensor.xh == true then										-- exception handler ?
		--print("EXCEPTION")
																										--******   GPS   *********	
			if label == "GPS+" or label == "GPS" then
				local value2,valHdop,valnSat,value2Strg
				--print("GPS detected")
				y = y + (frameX.h * 0.012)	+ 8		-- corrective y-placement
--				frame.drawBitmap(x,  y,  sensor.bmp,  iconsize.width*2,  iconsize.height*2,  frameX)
				frame.drawBitmapNative(x,  y,  sensor.bmp,  frameX)
				
				if demoMode == true then				-- demo mode ?
						value 	= sensors["gpsLat"].testVal				-- lat
						value2 	= sensors["gpsLon"].testVal		-- lon
						valnSat = sensors.nSat.testVal			-- nSat
						valHdop	= sensors.HDOP.testVal			-- hdop
				else
--						value 	= getTele("GPS",OPTION_LATITUDE)
--						value2	= getTele("GPS",OPTION_LONGITUDE)
						--print("GPS read",sensors["gpsLat"].name,sensors["gpsLat"].options)
						value 	= getTele(sensors["gpsLat"].name,sensors["gpsLat"].options)
						--print("GPS read",sensors["gpsLat"].name,sensors["gpsLon"].options)
						value2	= getTele(sensors["gpsLon"].name,sensors["gpsLon"].options)
						
						if label == "GPS+" then											-- GPS additional data
							valnSat = getTele(sensors["nSat"].name)
							if valnSat > 100 then valnSat = valnSat-100 end
							valHdop = getTele(sensors["HDOP"].name)
						end
				end
				
				-- gps coordinates
				valueStrg  = string.format("%." .. sensor.dec .. "f",value)				-- format decimals
				value2Strg = string.format("%." .. sensor.dec .. "f",value2)
				frame.drawText(89, y+0,  		valueStrg,  RIGHT ,  frameX)
				frame.drawText(89, y+0+dy*0.7, 	value2Strg, RIGHT ,  frameX)
				
				-- nsat & hdop
				if label == "GPS+" then	
					lcd.font(txtSize.sml)
					valueStrg  = string.format("%." .. sensors.nSat.dec .. "f",valnSat)	-- format decimals
					value2Strg = string.format("%." .. sensors.HDOP.dec .. "f",valHdop)
				
					local xTxt = 48					-- tab for additional data
					lcd.color(col_Value2)
					frame.drawText(xTxt, 		y-7, "nSat: ",  		RIGHT,	frameX)
					frame.drawText(xTxt+34, 	y-7, "hDop: ",  		RIGHT,  frameX)
					
					lcd.color(col_Value)
					frame.drawText(xTxt,		y-7,  valueStrg,  		LEFT , 	frameX)
					frame.drawText(xTxt+34, 	y-7,  value2Strg,		LEFT,  	frameX)
				end	
			

																												--******   Timer   *********	
			elseif 	string.sub(label,1,5) == "Timer" then
				
				local TimNo = tonumber(string.sub(label,6,6))-1							-- get timer index
				
				if sensor.bmp ~= nil then	

			--		frame.drawBitmap(x+sensor.alignB*frameX.w/1000,  y+bmpY,  sensor.bmp,  iconsize.width,  iconsize.height,  frameX) 
					frame.drawBitmapNative(x+sensor.alignB*frameX.w/1000,  y+bmpY,  sensor.bmp,  frameX)
				end
				if demoMode == true then				-- demo mode ?
					valueStrg = string.sub(sensor.testVal,2,10)
				else
					value =  model.getTimer(TimNo)
					valueStrg = tonumber(valueStrg)
					print("read real value",sensor.name,valueStrg)
				
				end
				frame.drawText(x+iconsize.width+xV_offset, y+2,  valueStrg, RIGHT ,  frameX)
			end
-- ***************************   standard handling **********************************************		
		
	else
	
		if sensor.bmp ~= nil then	
				--			x=start + alignB=BitMap alignment 
				
			--frame.drawBitmap(x+xB_offset,  y+bmpY,  sensor.bmp,  iconsize.width,  iconsize.height,  frameX) 
			frame.drawBitmapNative(x+xB_offset,  y+bmpY,   sensor.bmp,  frameX)
		end
		if demoMode == true then				-- demo mode ?
			value = sensor.testVal
			
		else
				value = getTele(sensor.name)
--				print("read real value",sensor.name,value)
		end
		
		if value ~= false then
		valueStrg = string.format("%." .. sensor.dec .. "f",value)		-- format decimals
		-- print("value  " .. valueStrg)
		tUnit = sensor.testUnit
												-- print value

		

		frame.drawText(x+iconsize.width+xV_offset, y+2,  valueStrg, RIGHT ,  frameX)		-- Value
		local y_font = 5
		lcd.font(txtSize.Xsml)
		lcd.color(theme.c_textgrey1)
		frame.drawText(x+iconsize.width+xV_offset, y+2+y_font,  tUnit, LEFT ,  frameX)
		end
--		print("horizon   x, iconsize, tab, alignV",sensor.label,x,iconsize.width,layout_T01.offTele1,sensor.alignV*frameX.w/1000)

	end
	
end


local function getActiveSensors(pageLayout)
	local page
	local line
	local entry_a
	local entry_b

	local sensorsCat	= {}	
	sensorsCat 	= defineSensors()				-- read complete sensor catalog
	
	local sensorsTmp	= {}
	for page = 1,#pageLayout do
		for line = 2,#pageLayout[page] do		-- offset 1 for header !
			if pageLayout[page][line][1] ~= nil then
				entry_a = pageLayout[page][line][1]
			end
			if pageLayout[page][line][2] ~= nil then
				entry_b = pageLayout[page][line][2]
			end
			
			print("got entries",entry_a,entry_b)		
			sensorsTmp[entry_a] = sensorsCat[entry_a]			
			sensorsTmp[entry_b] = sensorsCat[entry_b]
			
			if string.sub(entry_a,1,3) == "GPS" or string.sub(entry_a,1,3) == "GPS" then		-- exception GPS >> get sub entries too
				sensorsTmp["gpsLat"] = sensorsCat["gpsLat"]
				sensorsTmp["gpsLon"] = sensorsCat["gpsLon"]
				sensorsTmp["nSat"] 	 = sensorsCat["nSat"]				
				sensorsTmp["HDOP"]   = sensorsCat["HDOP"]								
			end
		end
	end
	return sensorsTmp
end

-- **************************************************************************************************
-- *************************    called on very first run / "init"  app     **************************
-- **************************************************************************************************
function tele01_frontendConfigure(widget,sensorSet)		
	
	print("got set",sensorset)	-- choosen sensor setlist
	
	loaded_chunk = assert(loadfile("/scripts/libUnow/widgets/tele01/value_sets.lua"))			-- different sets/suites of telemetry values
	loaded_chunk()

	loaded_chunk = assert(loadfile("/scripts/libUnow/widgets/tele_global/sensorlist.lua"))			-- special widget layout parameters , x/display dependent
	loaded_chunk()

	loaded_chunk = assert(loadfile("/scripts/libUnow/widgets/tele01/tele01_layout.lua"))			-- special widget layout parameters , x/display dependent
	loaded_chunk()
	
	local pagelayout = {}
	pageLayout = getValueSet(sensorSet)																		-- load specific value set
	
	local sensors = {}	
	loaded_chunk = assert(loadfile("/scripts/libUnow/lib_getTele.lua"))								-- get telemetry functions
	loaded_chunk()	
	
	sensors 	= getActiveSensors(pageLayout)			-- extract only those sensors we need to reduce mem load (bitmaps!)

	collectgarbage("collect")							-- garbage collection											
	return true,sensors,pageLayout
end


local function rowLayout(rows,dy,Yoffset)
	local Yline  = {}	
--	print("Y Layout:" ,rows)
	if rows == 4 then				-- 4 rows max:
		Yline = {																									-- "fine definition" of row placement, display dependend, 								
			{0+Yoffset,	dy+Yoffset,	2*dy+Yoffset,	3*dy+Yoffset,	4*dy+Yoffset},			-- type X20
			{2+Yoffset,	26+Yoffset,	50+Yoffset,		74+Yoffset,		72+Yoffset	},			-- type X18
			{0+Yoffset,	dy+Yoffset,	2*dy+Yoffset,	3*dy+Yoffset, 	4*dy+Yoffset},			-- type Horus									
			}		
	
	elseif rows == 5 then
		-- 5 rows max:
		Yline = {																																	
			{0+Yoffset,	dy+Yoffset,	2*dy+Yoffset,	3*dy+Yoffset,	4*dy+Yoffset},			-- type X20
			{2+Yoffset,	18+Yoffset,	36+Yoffset,		54+Yoffset,		72+Yoffset	},			-- type X18
			{0+Yoffset,	dy+Yoffset,	2*dy+Yoffset,	3*dy+Yoffset, 	4*dy+Yoffset},			-- type Horus									
			}
	end
	return Yline
end



-- **************************************************************************************
-- *************************      specific electro Tele draw functions **************************
-- **************************************************************************************


function tele01(frameX,page,layout,theme,touch,evnt,subConf,appConfigured,txt,widget)
	--print("garbage mem count returns",collectgarbage("count"))

	local number_cols = 2
	local demoMode 	= subConf[1]
	local sensorSet = subConf[2]
	
	local xx,yy
	local Yoffset = frameX.h * 0.04
	local bmpSize <const> = 12	
--	local bmpSize <const> = 13
	--local number_rows = {4,4,4}	
	local number_rows = {}					-- define number of rows per page
	local Yline = {}						-- 

	conf_teleEl()							-- define config string

	if page > #pageLayout then 
		page = 1
	end
													-- one time config; cant be executed during create cause window size not availabe then
	if not(appConfigured) then	
		-- ***************************    "init"       *********************************************************
		print("****************     INIT TELE01   *********************")
		for i = 1,#subConf do
		print("//////   MF conf passed:",i,subConf[i])
		end
		dspType = evaluate_display()											-- kind of display
		appConfigured,sensors,pageLayout 		= tele01_frontendConfigure(widget,sensorSet)			-- call one time function
		
		layout_T01 					= defineLayout(dspType)						-- app specific tabs etc...

		 
	end	
	
	

		
	for i = 1,#pageLayout  do					-- loop pages
		number_rows[i] = #pageLayout[i]-1		-- determine num of rows in page
	end
	
	local dy = (100 / (number_rows[page] +3))				-- insert "+n" virtual lines to compress on Y axis
	Yline = rowLayout(pageLayout.rows,dy,Yoffset)			-- determine row alignment
	

	-- draw header 
	drawBackground(frameX,theme)
	drawHeader(pageLayout[page][1][1],frameX,theme)
	
	
	
	-- ****************************************************	
	-- *******         		draw items				*******
	-- ****************************************************

	-- define iconsize (display dependent)
	local iconsize = {width=bmpSize, height = bmpSize}

	
	for col = 0,number_cols-1 do	
		for row = 0,number_rows[page]-1 do
	--		local dx = 100 / number_cols
			local dx = 50
			--if dx == 50 then dx=55 end										-- layout corrective in x axis
			
			if not(pageLayout[page][row+2][col+1] == nil) then				-- there is a telemetry value configured in layout
				local tmp = pageLayout[page][row+2][col+1]					-- get "internal" telemetry label
				--print("tmp",tmp)
				--print("name",sensors[tmp].name)
				local sensorTmp=sensors[tmp]									-- get sensor structure (label, bitmap etc..), defined by  defineSensors(widget) in sensorlist.lua
--				displayTele(tmp,sensorTmp,dx*col, Yline[dspType][row+1], iconsize, frameX,theme, dy,layout,layout_T01,sensors)
				displayTele(tmp,sensorTmp,dx*col, Yline[dspType][row+1], iconsize, frameX,theme, dy,layout,layout_T01,demoMode)
			end
		end
	end

--	collectgarbage("collect")							-- garbage collection	
	return appConfigured, page 	
end

